# -*- coding: utf-8 -*-
"""Modelo_pacientes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18JzjNlpaZ5YWv2ZsWalwEWSccoZ4cnv2

# **Función 1: limpiar datos**
"""

import pandas as pd
import numpy as np
from itertools import product
from sklearn.metrics import mean_absolute_error, mean_squared_error
from statsmodels.tsa.statespace.sarimax import SARIMAX
from prophet import Prophet
from scipy.stats import norm
import holidays
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error

def preparar_datos(filepath, fecha_inicio='2023-01-07', fecha_fin='2025-06-05'):
    df = pd.read_excel(filepath)
    df['Documento'] = df['Documento'].astype(str)
    df['Ingreso'] = df['Ingreso'].astype(str)
    df['visita'] = df['Documento'] + df['Ingreso']
    df['FechaIngreso'] = pd.to_datetime(df['FechaIngreso'])

    # Clasificación tipo contrato
    def tipo_contrato(sigla):
        sigla = str(sigla).strip().upper()
        return "Medicina prepagada" if sigla.startswith('MP') or sigla.startswith('MEDISANITAS') else "Seguro médico"

    df['TipoContrato'] = df['Sigla'].apply(tipo_contrato)

    # Agrupación semanal
    df_semanal = (
        df.groupby([pd.Grouper(key='FechaIngreso', freq='W'), 'TipoContrato'])
          .agg(PacientesUnicos=('visita', 'nunique'))
          .reset_index()
          .pivot(index='FechaIngreso', columns='TipoContrato', values='PacientesUnicos')
          .fillna(0)
    )

    return df_semanal.loc[fecha_inicio:fecha_fin]

df_pivot = preparar_datos('Informacion Pacientes Prepagada.xlsx')

"""# **Función 2: Entrenar modelos dados unos parámetros - Modelo SARIMAX**

"""

# --- F2: Entrenar modelo SARIMAX ---
def entrenar_arima(serie, columna, fecha_corte, semanas_prediccion=12,
                   order=(1, 1, 1), seasonal_order=(1, 1, 1, 52), nivel_confianza=0.95):

    y = serie[columna]
    fecha_corte_dt = pd.to_datetime(fecha_corte)
    fechas_validas = y.index[y.index <= fecha_corte_dt]

    if fechas_validas.empty:
        raise ValueError(f"La fecha de corte {fecha_corte} está antes del inicio de la serie.")

    fecha_corte_real = fechas_validas.max()
    train = y.loc[:fecha_corte_real]
    test_index = pd.date_range(start=fecha_corte_real + pd.Timedelta(weeks=1),
                               periods=semanas_prediccion, freq='W')

    modelo = SARIMAX(train, order=order, seasonal_order=seasonal_order,
                     enforce_stationarity=False, enforce_invertibility=False)
    resultado = modelo.fit(disp=False)

    forecast_obj = resultado.get_forecast(steps=len(test_index))
    pred = forecast_obj.predicted_mean
    ic = forecast_obj.conf_int(alpha=1 - nivel_confianza)

    ic_inf = ic.iloc[:, 0]
    ic_sup = ic.iloc[:, 1]
    pred.index = ic_inf.index = ic_sup.index = test_index

    # Parámetros del modelo
    parametros = {
        'modelo': 'SARIMAX',
        'order': order,
        'seasonal_order': seasonal_order,
        'params': resultado.params.to_dict(),
        'aic': resultado.aic,
        'bic': resultado.bic,
        'llf': resultado.llf
    }

    return pred, ic_inf, ic_sup, resultado, parametros

"""# **Función 3: Entrenar modelos dados unos parámetros - Prophet**"""

# --- F3: Entrenar modelo Prophet (modificado con todos los hiperparámetros) ---
def entrenar_prophet(serie, columna, fecha_corte, semanas_prediccion=12,
                     capacidad=None, crecimiento='linear', yearly=True, weekly=True,
                     usar_feriados=True, nivel_confianza=0.95):

    df = serie[[columna]].copy().reset_index()
    df.columns = ['ds', 'y']
    fecha_corte = pd.to_datetime(fecha_corte)
    fecha_corte_real = df[df['ds'] <= fecha_corte]['ds'].max()
    df_train = df[df['ds'] <= fecha_corte_real]

    if crecimiento == 'logistic':
        if capacidad is None:
            capacidad = df['y'].max() * 1.2
        df_train['cap'] = capacidad

    if usar_feriados:
        anios = list({d.year for d in df_train['ds']})
        festivos = holidays.Colombia(years=anios)
        holidays_df = pd.DataFrame([{
            'holiday': nombre,
            'ds': pd.to_datetime(fecha),
            'lower_window': -1,
            'upper_window': 1
        } for fecha, nombre in festivos.items()])
    else:
        holidays_df = None

    modelo = Prophet(
        growth=crecimiento if crecimiento == 'logistic' else 'linear',
        weekly_seasonality=weekly,
        yearly_seasonality=yearly,
        daily_seasonality=False,
        holidays=holidays_df,
        interval_width=nivel_confianza
    )
    modelo.fit(df_train)

    futuro = modelo.make_future_dataframe(periods=semanas_prediccion, freq='W')
    if crecimiento == 'logistic':
        futuro['cap'] = capacidad

    forecast = modelo.predict(futuro)
    pred = forecast.set_index('ds').iloc[-semanas_prediccion:]['yhat']
    ic_inf = forecast.set_index('ds').iloc[-semanas_prediccion:]['yhat_lower']
    ic_sup = forecast.set_index('ds').iloc[-semanas_prediccion:]['yhat_upper']

    # Parámetros del modelo Prophet, incluyendo configuración de estacionalidad y crecimiento
    parametros = {
        'modelo': 'Prophet',
        'growth': crecimiento,
        'capacidad': capacidad if crecimiento == 'logistic' else None,
        'interval_width': nivel_confianza,
        'weekly_seasonality': weekly,
        'yearly_seasonality': yearly,
        'usar_feriados': usar_feriados,
        'coeficientes': {k: v.mean(axis=0).tolist() for k, v in modelo.params.items()}
    }

    return pred, ic_inf, ic_sup, modelo, parametros

"""# **Funciones auxiliares: cálculo de error**"""

# --- Métricas ---
def calcular_rmse(serie_real, predicciones):
    return np.sqrt(mean_squared_error(serie_real, predicciones))

def calcular_mae(serie_real, predicciones):
    return mean_absolute_error(serie_real, predicciones)

"""# **Función 4: Graficar resultados del modelo**"""

# --- F4: Gráfico ---
import matplotlib.pyplot as plt
import pandas as pd

def graficar_predicciones(serie_real, fecha_corte, modelos, titulo='Predicción vs Realidad'):
    plt.figure(figsize=(12, 6))
    fecha_corte = pd.to_datetime(fecha_corte)
    entrenamiento = serie_real[serie_real.index <= fecha_corte]
    testeo = serie_real[serie_real.index > fecha_corte]

    if not entrenamiento.empty:
        plt.plot(entrenamiento.index, entrenamiento.values, label='Entrenamiento real', color='black')
    if not testeo.empty:
        plt.plot(testeo.index, testeo.values, label='Testeo real', color='gray')

    colores = ['red', 'blue', 'green', 'orange', 'purple', 'steelblue', 'teal', 'darkcyan', 'crimson', 'olive']
    for i, (nombre, datos) in enumerate(modelos.items()):
        color = colores[i % len(colores)]
        pred = datos['pred']
        ic_inf = datos.get('ic_inf')
        ic_sup = datos.get('ic_sup')
        p = datos.get('parametros', {})

        # --- Parámetros del modelo ---
        if nombre == 'SARIMAX':
            resumen = f"(order={p.get('order')}, seasonal={p.get('seasonal_order')})"
        elif nombre == 'Prophet':
            resumen = f"(growth={p.get('growth')}, yearly={p.get('yearly_seasonality')}, weekly={p.get('weekly_seasonality')}, feriados={p.get('usar_feriados')})"
        else:
            resumen = ""

        # --- Errores (RMSE y MAE) ---
        errores = []
        if 'error_rmse' in datos:
            errores.append(f"RMSE: {datos['error_rmse']:.2f}")
        if 'error_mae' in datos:
            errores.append(f"MAE: {datos['error_mae']:.2f}")
        texto_error = " | ".join(errores)

        # --- Etiqueta final ---
        label_pred = f'{nombre} {resumen} | {texto_error}'
        plt.plot(pred.index, pred.values, label=label_pred, color=color)

        # --- Intervalos de confianza ---
        if ic_inf is not None and ic_sup is not None:
            try:
                ic_inf = ic_inf.reindex(pred.index).fillna(method='ffill')
                ic_sup = ic_sup.reindex(pred.index).fillna(method='bfill')
                plt.fill_between(pred.index, ic_inf, ic_sup, color=color, alpha=0.2, label=f'IC {nombre}')
            except Exception as e:
                print(f"[Error] Intervalo {nombre}: {e}")

    plt.axvline(fecha_corte, color='gray', linestyle='--', label='Fecha de corte')
    plt.title(titulo)
    plt.xlabel('Fecha')
    plt.ylabel('Valor')
    plt.legend()
    plt.tight_layout()
    plt.show()

"""# **Función 5: Grid Search de ARIMA**"""

# --- F5: Gridsearch ARIMA ---
def gridsearch_arima(serie, columna, fecha_corte, semanas_prediccion,
                     orders, seasonal_orders, metric='rmse'):
    """
    GridSearch para SARIMAX. Retorna el mejor modelo y la tabla con todas las combinaciones evaluadas.
    """
    nombre_error = f"error_{metric}"

    # Lista para guardar todos los resultados evaluados
    historial_resultados = []

    # Diccionario para guardar el mejor modelo
    mejor_modelo = {
        nombre_error: float('inf'),
        'tipo_error': metric,
        'params': None,
        'pred': None,
        'ic_inf': None,
        'ic_sup': None,
        'modelo': None,
        'parametros': None
    }

    real = serie[columna]
    fecha_corte_dt = pd.to_datetime(fecha_corte)
    y_test = real[real.index > fecha_corte_dt].iloc[:semanas_prediccion]

    for order in orders:
        for seasonal_order in seasonal_orders:
            try:
                pred, ic_inf, ic_sup, modelo, params = entrenar_arima(
                    serie, columna, fecha_corte,
                    semanas_prediccion, order=order,
                    seasonal_order=seasonal_order
                )
                pred = pred.reindex(y_test.index).dropna()
                y_true = y_test.reindex(pred.index).dropna()

                score = calcular_rmse(y_true, pred) if metric == 'rmse' else calcular_mae(y_true, pred)

                # Guardar en el historial
                historial_resultados.append({
                    'order': order,
                    'seasonal_order': seasonal_order,
                    'error': score
                })

                # Verificar si es el mejor
                if score < mejor_modelo[nombre_error]:
                    mejor_modelo.update({
                        nombre_error: score,
                        'params': {'order': order, 'seasonal_order': seasonal_order},
                        'pred': pred,
                        'ic_inf': ic_inf,
                        'ic_sup': ic_sup,
                        'modelo': modelo,
                        'parametros': params
                    })

            except Exception:
                continue

    # Retorna el mejor modelo y el historial completo
    return mejor_modelo, historial_resultados

"""# **Función 6: Gridsearch Prophet**"""

# --- F6: Gridsearch Prophet ---

def gridsearch_prophet(serie, columna, fecha_corte, semanas_prediccion,
                       growth_options=['linear'], yearly_options=[True], weekly_options=[True],
                       usar_feriados_options=[True], metric='rmse'):
    """
    GridSearch para Prophet. Retorna:
      - mejor_modelo: diccionario con info del mejor modelo
      - historial: lista de diccionarios con parámetros y error de todas las combinaciones
    """
    nombre_error = f"error_{metric}"

    historial_resultados = []

    mejor_modelo = {
        nombre_error: float('inf'),
        'tipo_error': metric,
        'params': None,
        'pred': None,
        'ic_inf': None,
        'ic_sup': None,
        'modelo': None,
        'parametros': None
    }

    real = serie[columna]
    fecha_corte_dt = pd.to_datetime(fecha_corte)
    y_test = real[real.index > fecha_corte_dt].iloc[:semanas_prediccion]

    for growth in growth_options:
        for yearly in yearly_options:
            for weekly in weekly_options:
                for usar_feriados in usar_feriados_options:
                    try:
                        pred, ic_inf, ic_sup, modelo, params = entrenar_prophet(
                            serie, columna, fecha_corte, semanas_prediccion,
                            crecimiento=growth, yearly=yearly, weekly=weekly,
                            usar_feriados=usar_feriados
                        )
                        pred = pred.reindex(y_test.index).dropna()
                        y_true = y_test.reindex(pred.index).dropna()

                        score = calcular_rmse(y_true, pred) if metric == 'rmse' else calcular_mae(y_true, pred)

                        # Guardar en historial
                        historial_resultados.append({
                            'growth': growth,
                            'yearly': yearly,
                            'weekly': weekly,
                            'usar_feriados': usar_feriados,
                            'error': score
                        })

                        # Verificar si es el mejor
                        if score < mejor_modelo[nombre_error]:
                            mejor_modelo.update({
                                nombre_error: score,
                                'params': {
                                    'growth': growth,
                                    'yearly': yearly,
                                    'weekly': weekly,
                                    'usar_feriados': usar_feriados
                                },
                                'pred': pred,
                                'ic_inf': ic_inf,
                                'ic_sup': ic_sup,
                                'modelo': modelo,
                                'parametros': params
                            })

                    except Exception:
                        continue

    return mejor_modelo, historial_resultados

"""# **Ejecución del grid search - SARIMAX**"""

columna = 'Seguro médico'
fecha_corte = '2024-12-01'
semanas_prediccion = 48

orders = [(1,0,0), (1,1,1), (2,1,0)]
seasonal_orders = [(0,1,1,52), (1,0,1,52), (1,1,1,52)]

mejor_modelo_SARIMAX, historial_SARIMAX = gridsearch_arima(df_pivot, columna, fecha_corte, semanas_prediccion, orders = orders, seasonal_orders= seasonal_orders, metric='rmse')

historial_df_SARIMAX = pd.DataFrame(historial_SARIMAX).sort_values(by='error')
historial_df_SARIMAX

"""# **Ejecución del Gridsearch - Prophet**"""

columna = 'Seguro médico'
fecha_corte = '2024-12-01'
semanas_prediccion = 48

# Combinaciones a evaluar
growth_options = ['linear', 'logistic']
yearly_options = [True, False]
weekly_options = [True]
usar_feriados_options = [True, False]

# Ejecutar gridsearch
mejor_modelo_prophet, historial_prophet = gridsearch_prophet(
    df_pivot,
    columna,
    fecha_corte,
    semanas_prediccion,
    growth_options=growth_options,
    yearly_options=yearly_options,
    weekly_options=weekly_options,
    usar_feriados_options=usar_feriados_options,
    metric='rmse'
)

historial_df_prophet = pd.DataFrame(historial_prophet).sort_values(by='error')
historial_df_prophet

"""# **Graficación**"""

# Seleccionamos los parámetros mejores para ambos modelos

order_SARIMAX = historial_df_SARIMAX.iloc[0][0]
seasonal_order_SARIMAX = historial_df_SARIMAX.iloc[0][1]

growth_prophet = historial_df_prophet.iloc[0][0]
yearly_prophet = historial_df_prophet.iloc[0][1]
weekly_prophet = historial_df_prophet.iloc[0][2]
usar_feriados_prophet = historial_df_prophet.iloc[0][3]

def entrenar_y_evaluar(modelo_nombre, funcion_entrenamiento, df, columna, fecha_corte, semanas_prediccion, **kwargs):
    """
    Entrena el modelo, alinea con la realidad, calcula RMSE y MAE, y retorna diccionario listo para graficar.
    """
    # Entrenar modelo
    pred, ic_inf, ic_sup, modelo, params = funcion_entrenamiento(
        df, columna, fecha_corte, semanas_prediccion, **kwargs
    )

    # Cortar y alinear serie real
    fecha_corte_dt = pd.to_datetime(fecha_corte)
    y_test = df[columna][df.index > fecha_corte_dt].iloc[:semanas_prediccion]
    pred_alineado = pred.reindex(y_test.index).dropna()
    y_test_alineado = y_test.reindex(pred_alineado.index).dropna()

    # Calcular errores
    rmse = calcular_rmse(y_test_alineado, pred_alineado)
    mae = calcular_mae(y_test_alineado, pred_alineado)

    # Armar diccionario final
    modelo_dict = {
        'pred': pred,
        'ic_inf': ic_inf,
        'ic_sup': ic_sup,
        'parametros': params,
        'error_rmse': rmse,
        'error_mae': mae
    }

    return modelo_nombre, modelo_dict

# --- Entrenar y evaluar modelos ---
modelo_sarimax, dict_sarimax = entrenar_y_evaluar(
    'SARIMAX',
    entrenar_arima,
    df_pivot,
    columna,
    fecha_corte,
    semanas_prediccion,
    order=order_SARIMAX,
    seasonal_order=seasonal_order_SARIMAX
)

modelo_prophet, dict_prophet = entrenar_y_evaluar(
    'Prophet',
    entrenar_prophet,
    df_pivot,
    columna,
    fecha_corte,
    semanas_prediccion,
    crecimiento=growth_prophet,
    yearly=yearly_prophet,
    weekly=weekly_prophet,
    usar_feriados=usar_feriados_prophet
)

# --- Diccionario final para graficar ---
modelos = {
    modelo_sarimax: dict_sarimax,
    modelo_prophet: dict_prophet
}

graficar_predicciones(df_pivot[columna], fecha_corte, modelos)